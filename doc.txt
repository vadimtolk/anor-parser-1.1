.futhconf // Техническая документация (уровень реализации)

White Paper (функциональные аспекты) :

	Алгоритм лексера (lexer.asm) :
		1. Открывает файл ".futhconf", расширяет его для выгрузки в память и вышружает его. 
		2. Считывает строчку до терминатора, попутно проверяя ее на валидность (корректность синтаксиса)
		3. Применяет функции для прочитанной строки :
			3.1 rmsp.asm - убирает пробелы между оператором и аргументами (если они есть), участвует в разбитии строки на лексемы
			3.2 hash.asm - хэширует поле, которое считано в строке 
			3.3 bsrch.asm - бинарный поиск для работы со строками. Проверяет наличие хэша среди корректных
			3.4 toint.asam - перевод строки со значением (value) поля к целочисленному формату
		4. Заполняет структуру с конечными значениями 
		5. Возвращает структуру в парсер
		6. Закрывает выгрузку в файла память, "сужает" его до первоначальных размеров и закрывает файл
		7. Если что то пошло не так, аварийно закрывает файл и выводит информацию об ошибке

	Парсер реализован прямо в "futh-utils.h" в "TestUser::calculateAnor()" (он высчитывает заранее оговоренные места в памяти, соответствующие определенным полям). 

Yellow Paper (нефункциональные аспекты) :
	
	Алгоритм лексера (lexer.asm) :
		0. Сохраняем состояние регистров [RAX - R15] (частично в futh-utils.h) для последующего восстановления после завершения программы (иначе UB / SEGFAULT) 
		1. Подготовка файла
			1.1 Открытие файла происходит с флагами O_RDWR & rw-rw-rw (это нужно для sys_ftruncate) по текущему пути. Файл должен быть создан к моменту запуска программы, иначе ошибка. 
			1.2 Искусственное расширение файла на 4096 байт (размер одной страницы) по дескриптору, полученному в sys_open (п 1.1)
			1.3 Выгрузка 4096 байт файла в оперативную память (mmap). PROT_READ, MAP_PRIVATE и последующее сохранение указателя на первый байт записи (текущий для перехода по строкам и начальный, иммутабельный, для munmap)
		2. Переход в main-loop:
			2.2 Сначала проверим, что файл не пустой :
				2.2.1 Если символ - нуль-терминатор ('\0'), то 2 варианта : либо прочитали все строки, либо нет ни одной. Переходим на метку final и проверяем длину строки (побитовое И без перезаписи аргумента). Если она = 0, то файл пустой (ошибка)
				2.2.2 Некоторые IDE, например VIM, устанавливают символ переноса строки '\n' в конец текста по POSIX стандарту, поэтому если первый символ равен '\n' (0xA), то файл пустой (ошибка)
			2.3 Парсинг строки :
				2.3.1 Читаем строку до терминатора ";", инкрементируя счетчик (он отвечает за длину строки).
				2.3.2 Если встречаем символ "=", то декрементируем флаг (отвечающий за наличие "="), который изначально установлен в единицу. Таким образом, если флаг == 0, то символ "=" есть в строке и он один
				2.3.3 Если прочитали 20 символов и не нашли терминатор - синтаксическая ошибка (отсутствие терминатора), т.к длина строки должна быть не более 20 символов (на текущий момент).	
				2.3.4 Если строка начинается с "=" - синтаксическая ошибка
				2.3.5 В конце добавляем рассчитанную длину строки к переменной, хранящей совокупную длину строки
			2.4 Валидация строки :
				2.4.1 Удаление пробелов :
					2.4.1.1 Парсинг строки до первого пробела, сохраняем индекс в dest (RDI), сохраняем состояния RDI, RCX, сохранение длины строки (индекс терминатора + 1)
					2.4.1.2 Перемещаем src (RSI) на один байт дальше и декрементируем количество итераций (для rep) чтобы четко переместить значения вместо пробела. Восстанавливаем RDI, RDX
					2.4.1.3 Если после символа "=" идет пробел, то функционал замены индекса не затрагивается, так как по последнему пробелу высчитывается индекс начала строки со значением поля
					2.4.1.4 Если после символа "=" пробела нет, то запоминаем его индекс и его индекс + 1 = индекс начала строки со значением поля
					2.4.1.5 В конце вычисляем длину строки со значением поля : [ИНДЕКС ТЕРМИНАТОРА (ПОСЛЕДНИЙ СИМВОЛ + 1) - ИНДЕКС НАЧАЛА СТРОКИ СО ЗНАЧЕНИЕМ], предварительно декрементировав длину строки
					2.4.1.6 Возвращаем индекс первого байта (начала строки), длину строки со значением и адрес буфера, в который записана строка без пробелов
					2.4.1. В конце зануляем переменные с индексами, чтобы не было конфликта на следующих итерациях
				2.4.2 Хэширование строки с названием поля :
					2.4.2.1 Вычисляем длину строки до символа "=" и записываем результат в R8
					2.4.2.2 Берем текущий символ цикла (сразу инкрементируем указатель на буфер), прибавляем к нему текущий символ вложенного цикла, складываем и делим на 2 (хэш-функция)
					2.4.2.3 Добавляем полученные символы в хэш-буфер пока не выполнится одно из двух условий : 
						|-RCX == 0 :
						|--> буфер полностью заполнен, выход с возвратом адреса хэша
				
						|-R10 == 0 :
						|--> "прошагали" всю строку, переходим к следующему символу для вычисления хэша. Восстанавливаем R10, переходим на п. 2.4.2.2
				2.4.3 Бинарный поиск хэша среди константных хэшей (так же используется для поиска цифры как символа строки) :
					2.4.3.1 Прнинимаем параметры : адрес константных хэшей, адрес вычисленного хэша, длина хэша, индекс последнего хэша среди константных хэшей
					2.4.3.2 Сохраняем состояния RDI & RSI (после repe cmpsb они инвалидируются - будут указывать не на начало)
					2.4.3.3 Пока последний индекс больше или равен первому индексу вычисляем серединный элемент [(ИНДЕКС НАЧ. + ИНДЕКС КОН.) / 2 * ДЛИНА ХЭША ] (если вдруг осталось 2 элемента, первый из них опорный и эл-т поиска меньше опорного, то break)
					2.4.3.4 Сравниваем "серединный хэш" с вычисленным хэшем. Если он равен - выходим из цикла. Если больше - ИНДЕКС НАЧ. = ИНДЕКС ЦЕНТР. + 1; иначе ИНДЕКС КОН. = ИНДЕКС ЦЕНТР. - 1. & восстанавливаем RDI, RSI
					2.4.3.5 Сохраненный индекс сдвига возвращаем (по нему будет вычислять сдвиг в val-структуре)
					2.4.3.5 Если после неудачного сравнения оказалось, что ИНДЕКС НАЧ. = ИНДЕКС КОН. то элемент не найден (ошибка)
				2.4.4 Каст строки к целочиленному значению :
					2.4.4.1 Сохраняем указатель на верхушку стека RSP (чтобы потом сетнуть его обратно)
					2.4.4.2 Принимаем параметры : индекс начала записи значений поля, длина строки со значением поля
					2.4.4.3 Сохраняем состояния регистров, которые изменются после бинарного поиска, в стек
					2.4.4.4 Начинаем парсинг с последнего элемента (НАЧАЛО + ДЛИНА СТР. - 1)
					2.4.4.5 Кладем аргументы в стек для bsrch
					2.4.4.6 Получаем индекс элемента в строке из цифр от 0 до 9, который и является фактической цифрой для прибавления к аккумулятору. Умножаем его на 10^n, где n - индекс текущего байта (например, самый младший байт умножаем на 10^0)
					2.4.4.7 (Предворительно мы восстановили состояние регистров, вытащив их из стека) Сохраняем адрес RSP как последний SP (stack-pointer)
					2.4.4.8 Возвращаем аккумулятор (RAX) и последний sp (RDI).
			2.5 Вычисляем сдвиг в val-структуре и записываем значение RAX 
			2.5 Восстанавливаем состояния регистров, очищаем буфер для строки, устанавливаем флаг символа "=" в 1, переходим к следующей строке 
		3. Финализация :
			3.1 Проверяем, не нулевая ли длина строки? Если да, то ошибка
			3.2 Полностью очищаем стек (пока текущий адрес != адресу сохраненного RSP в п. 0, зануляем все 8 байтовые ячейки) 
		4. Закрытие файла :
			4.4 Обрезаем файл через ftruncate по дескриптору и совокупной длине.
			4.5 Закрываем выгрузку файла в память через munmap
			4.6 Закрываем файл по дескриптору
		5. Выброс исключения (throw)
			5.1 Аварийное закрытие файлы аналогично пунктам 4.4 - 4.6
			5.2 Установка статуса ошибки
			5.3 Закрытие программы 
